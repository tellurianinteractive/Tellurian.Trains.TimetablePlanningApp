@if (Current is null)
{

}
else
{
    <div>
        <h3>@Current.Description</h3>
        <input id="toggleAxis" type="checkbox" @onchange="ToggleAxis" />
        <label for="toggleAxis">Check to vertical time axis</label>
        <input id="toggleDepartureMinutes" type="checkbox" @onchange="ToggleDepartureMinutes" />
        <label for="toggleDepartureMinutes">Check to show departure minutes</label>
        <input id="toggleArrivalMinutes" type="checkbox" @onchange="ToggleArrivalMinutes" />
        <label for="toggleArrivalMinutes">Check to show arrival minutes</label>
    </div>
    <div>
        <svg style="border: 1pt solid black " height="@Current.Height()" width="@Current.Width()" @onclick="OnClick" @onmousedown="OnMouseDown">
            <defs>
                <filter x="0" y="0" width="1" height="1" id="solid">
                    <feFlood flood-color="white" result="bg" />
                    <feMerge>
                        <feMergeNode in="bg" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>
            @* Draw hours *@
            @for (var time = Current.StartTime; time <= Current.EndTime; time += TimeSpan.FromHours(1))
            {
                var hourOffset = Current.TimeAxisLabelOffset(time);
                <text>
                    <text class="@Current.AxisDirection.OrientationCss("hour")" x="@hourOffset.X" y="@hourOffset.Y">@time.Hours</text>
                </text>
                var timeLine = Current.TimeLine(time);
                <line class="timeline" x1="@timeLine.Start.X" y1="@timeLine.Start.Y" x2="@timeLine.End.X" y2="@timeLine.End.Y"></line>
            }

            @* Draw stations*@
            @for (var s = 0; s < Current.Stations.Length; s++)
            {
                var stationOffset = Current.StationLabelOffset(s);
                var kmOffset = Current.KmLabelOffset(s);
                <text>
                    <text>
                        <tspan x="@stationOffset.X" y="@stationOffset.Y" class="@Current.AxisDirection.OrientationCss( "stationname")">@Current.Stations[s].NameLabel()</tspan>
                        <tspan x="@kmOffset.X" y="@kmOffset.Y" class="@Current.AxisDirection.OrientationCss( "stationkm")">@Current.Stations[s].KmLabel()</tspan>
                    </text>
                </text>
                @* Draw station tracks*@
                @for (var t = 0; t < Current.Stations[s].Tracks.Length; t++)
                {
                    var track = Current.Stations[s].Tracks[t];
                    var trackNumber = Current.TrackNumberOffset(s, t);
                    <text>
                        <text class="@Current.AxisDirection.OrientationCss("number")" x="@trackNumber.X" y="@trackNumber.Y">@track.Number</text>
                    </text>
                    var trackLine = Current.TrackLine(s, t);
                    <line stroke="@TrackStroke(track)" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                }
            }

            @* Draw trains *@
            @for (var s = 0; s < Current.Stations.Length; s++)
            {
                var station = Current.Stations[s];
                @for (var t = 0; t < Current.Stations[s].Tracks.Length; t++)
                {
                    var track = station.Tracks[t];
                    @foreach (var stationCall in Current.Trains.SelectMany(t => t.Calls.Where(c => track.Equals(c.Track) && station.Equals(c.Track.Station))))
                    {
                        var trackLine = Current.TrainAtStationLine(s, t, stationCall);
                        <line stroke=@stationCall.Train?.Colour stroke-width="@TrainStrokeWidth" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                    }
                }
            }

            @for (var toStationIndex = 1; toStationIndex < Current.Stations.Length; toStationIndex++)
            {
                var fromStationIndex = toStationIndex - 1;
                var fromStation = Current.Stations[fromStationIndex];
                var toStation = Current.Stations[toStationIndex];

                @for (var fromTrackIndex = 0; fromTrackIndex < Current.Stations[fromStationIndex].Tracks.Length; fromTrackIndex++)
                {
                    var fromTrack = Current.Stations[fromStationIndex].Tracks[fromTrackIndex];
                    for (var toTrackIndex = 0; toTrackIndex < Current.Stations[toStationIndex].Tracks.Length; toTrackIndex++)
                    {
                        var toTrack = Current.Stations[toStationIndex].Tracks[toTrackIndex];

                        @foreach (var stretch in Current.Trains.SelectMany(t => t.StretchUses().Where(c => fromStation.Equals(c.From.Track.Station) && c.From.Track.Equals(fromTrack) && toStation.Equals(c.To.Track.Station) && c.To.Track.Equals(toTrack))))
                        {
                            var trackLine = Current.TrainBetweenStationsLine(fromStationIndex, fromTrackIndex, toStationIndex, toTrackIndex, stretch.From.Departure, stretch.To.Arrival);
                            <line stroke=@stretch.Train.Colour stroke-width="@TrainStrokeWidth" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                        }
                    }
                }
            }

            @for (var fromStationIndex = Current.Stations.Length - 1; fromStationIndex > 0; fromStationIndex--)
            {
                var toStationIndex = fromStationIndex - 1;
                var fromStation = Current.Stations[fromStationIndex];
                var toStation = Current.Stations[toStationIndex];

                @for (var fromTrackIndex = 0; fromTrackIndex < fromStation.Tracks.Length; fromTrackIndex++)
                {
                    var fromTrack = fromStation.Tracks[fromTrackIndex];
                    for (var toTrackIndex = 0; toTrackIndex < toStation.Tracks.Length; toTrackIndex++)
                    {
                        var toTrack = toStation.Tracks[toTrackIndex];

                        @foreach (var stretch in Current.Trains.SelectMany(t => t.StretchUses().Where(c => fromStation.Equals(c.From.Track.Station) && c.From.Track.Equals(fromTrack) && toStation.Equals(c.To.Track.Station) && c.To.Track.Equals(toTrack))))
                        {
                            var trackLine = Current.TrainBetweenStationsLine(fromStationIndex, fromTrackIndex, toStationIndex, toTrackIndex, stretch.From.Departure, stretch.To.Arrival);
                            <line stroke=@stretch.Train.Colour stroke-width="@TrainStrokeWidth" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                            var departure = Current.DepartureMinuteOver(fromStationIndex, stretch.From);
                            @if (Current.GraphSettings.ShowDepartureMinutes)
                            {
                                <text>
                                    <text filter="url(#solid)" class="@Current.AxisDirection.OrientationCss("minute")" x="@departure.X" y="@departure.Y">@stretch.From.Departure.Minutes()</text>
                                </text>
                            }
                            @if (Current.GraphSettings.ShowArrivalMinutes)
                            {
                                var arrival = Current.ArrivalMinuteUnder(toStationIndex, toTrackIndex, stretch.To);
                                <text>
                                    <text filter="url(#solid)" class="@Current.AxisDirection.OrientationCss("minute")" x="@arrival.X" y="@arrival.Y">@stretch.To.Arrival.Minutes()</text>
                                </text>
                            }
                        }
                    }
                }
            }
            @for (var toStationIndex = 1; toStationIndex < Current.Stations.Length; toStationIndex++)
            {
                var fromStationIndex = toStationIndex - 1;
                var fromStation = Current.Stations[fromStationIndex];
                var toStation = Current.Stations[toStationIndex];

                @for (var fromTrackIndex = 0; fromTrackIndex < Current.Stations[fromStationIndex].Tracks.Length; fromTrackIndex++)
                {
                    var fromTrack = Current.Stations[fromStationIndex].Tracks[fromTrackIndex];
                    for (var toTrackIndex = 0; toTrackIndex < Current.Stations[toStationIndex].Tracks.Length; toTrackIndex++)
                    {
                        var toTrack = Current.Stations[toStationIndex].Tracks[toTrackIndex];

                        @foreach (var stretch in Current.Trains.SelectMany(t => t.StretchUses().Where(c => fromStation.Equals(c.From.Track.Station) && c.From.Track.Equals(fromTrack) && toStation.Equals(c.To.Track.Station) && c.To.Track.Equals(toTrack))))
                        {
                            var departure = Current.DepartureMinuteUnder(fromStationIndex, fromTrackIndex, stretch.From);
                            @if (Current.GraphSettings.ShowDepartureMinutes)
                            {
                                <text>
                                    <text filter="url(#solid)" class="@Current.AxisDirection.OrientationCss("minute")" x="@departure.X" y="@departure.Y">@stretch.From.Departure.Minutes()</text>
                                </text>
                            }
                            @if (Current.GraphSettings.ShowArrivalMinutes)
                            {
                                var arrival = Current.ArrivalMinuteOver(toStationIndex, stretch.To);
                                <text>
                                    <text filter="url(#solid)" class="@Current.AxisDirection.OrientationCss("minute")" x="@arrival.X" y="@arrival.Y">@stretch.To.Arrival.Minutes()</text>
                                </text>
                            }
                        }
                    }
                }
            }
        </svg>
    </div>
}

<br />
<ul>
    @foreach (var e in Events)
    {
        <li>@e.Type (@e.Args.OffsetX @e.Args.OffsetY) (@e.Args.ClientX @e.Args.ClientY) (@e.Args.ScreenX @e.Args.ScreenY)</li>
    }
</ul>

@code
{
    [Parameter] public IEnumerable<Schedule>? TimetableStretches { get; set; }
    [Parameter] public GraphSettings Settings { get; set; } = GraphSettings.Default;

    Schedule? Current;
    bool ShowVertical;

    string TrackStroke(StationTrack t) => t.HasPlatform ? "#404040" : t.IsScheduled ? "#bfbfbf" : "#ff8080";
    string TrainStroke(Train t) => t.Colour;
    string TrainStrokeWidth => "4";
    string Time(CallAction callAction) => $"{callAction.Time:HH:mm}";


    void ToggleAxis()
    {
        ShowVertical = !ShowVertical;
        if (Current is not null) Current.GraphSettings.AxisDirection = ShowVertical ? TimeAxisDirection.Vertical : TimeAxisDirection.Horisontal;
    }

    void ToggleDepartureMinutes()
    {
        if (Current is not null) Current.GraphSettings.ShowDepartureMinutes = !Current.GraphSettings.ShowDepartureMinutes;
    }
    void ToggleArrivalMinutes()
    {
        if (Current is not null) Current.GraphSettings.ShowArrivalMinutes = !Current.GraphSettings.ShowArrivalMinutes;
    }

    List<(MouseEventArgs Args, string Type)> Events = new List<(MouseEventArgs, string)>();

    protected override void OnParametersSet()
    {
        Current = TimetableStretches?.FirstOrDefault();
        if (Current is null) return;
        Current.GraphSettings.ShowArrivalMinutes = false;
        Current.GraphSettings.ShowDepartureMinutes = false;
    }

    void OnClick(MouseEventArgs e)
    {
        Events.Add((e, nameof(OnClick)));
    }

    void OnMouseDown(MouseEventArgs e)
    {

        //Events.Add((e, nameof(OnMouseDown)));
        //StateHasChanged();
        // Find out what object was clicked:
        // A train between two stations: dragging it moves the rest of the train forwards or backwards in time. Check limits: train part not affected by the move, and start and end limits of schedule.
        // An arrival at a station: dragging it moves the time forwards or backwards in time. Check limits: train part not affected by the move, and start and end limits of schedule.
        // A departure at a station: dragging it moves the time forwards or backwards in time. Check limits: train part not affected by the move, and start and end limits of schedule.
        // A wait at a station: dragging between tracks.
    }

    void OnMouseUp(MouseEventArgs e)
    {
        //Events.Add((e, nameof(OnMouseUp)));
        //StateHasChanged();
        // If object is selected: ends the dragging

    }

    void OnMouseMove(MouseEventArgs e)
    {
        //Events.Add(e);
        //StateHasChanged();
        // If object is selected: performs the dragging
    }

    void OnMouseOut(MouseEventArgs e)
    {
        //Events.Add((e, nameof(OnMouseOut)));
        //StateHasChanged();
        // Cancels operations?
    }

    void OnMouseOver(MouseEventArgs e)
    {
        //Events.Add((e, nameof(OnMouseOver)));
        //StateHasChanged();
        // Highlights objects that are selectable? This is similar to actuallt select something.
    }
}