@if (Current is null)
{

}
else
{
    <div>
        <h3>@Current.Description</h3>
        <input id="toggleAxis" type="checkbox" @onchange="ToggleAxis" />
        <label for="toggleAxis">Check to vertical time axis</label>
    </div>
    <div>
        <svg style="border: 1pt solid black " height="@Current.Height(AxisDirection)" width="@Current.Width(AxisDirection)" @onclick="OnClick" @onmousedown="OnMouseDown">
            @* Draw hours *@
            @for (var time = Current.StartTime; time <= Current.EndTime; time += TimeSpan.FromHours(1))
            {
                var hourOffset = Current.TimeAxisLabelOffset(AxisDirection, time);
                <text>
                    <text class="@AxisDirection.OrientationCss("time")" x="@hourOffset.X" y="@hourOffset.Y">@time.Hours</text>
                </text>
                var timeLine = Current.TimeLine(AxisDirection, time);
                <line class="timeline" x1="@timeLine.Start.X" y1="@timeLine.Start.Y" x2="@timeLine.End.X" y2="@timeLine.End.Y"></line>
            }

            @* Draw stations*@
            @for (var s = 0; s < Current.Stations.Length; s++)
            {
                var stationOffset = Current.StationLabelOffset(AxisDirection, s);
                var kmOffset = Current.KmLabelOffset(AxisDirection, s);
                <text>
                    <text>
                        <tspan x="@stationOffset.X" y="@stationOffset.Y" class="@AxisDirection.OrientationCss( "stationname")">@Current.Stations[s].NameLabel()</tspan>
                        <tspan x="@kmOffset.X" y="@kmOffset.Y" class="@AxisDirection.OrientationCss( "stationkm")">@Current.Stations[s].KmLabel()</tspan>
                    </text>
                </text>
                @* Draw station tracks*@
                @for (var t = 0; t < Current.Stations[s].Tracks.Length; t++)
                {
                    var track = Current.Stations[s].Tracks[t];
                    var trackNumber = Current.TrackNumberOffset(AxisDirection, s, t);
                    <text>
                        <text class="@AxisDirection.OrientationCss("number")" x="@trackNumber.X" y="@trackNumber.Y">@track.Number</text>
                    </text>
                    var trackLine = Current.TrackLine(AxisDirection, s, t);
                    <line stroke="@TrackStroke(track)" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                }
            }

            @* Draw trains *@
            @for (var s = 0; s < Current.Stations.Length; s++)
            {
                var station = Current.Stations[s];
                @for (var t = 0; t < Current.Stations[s].Tracks.Length; t++)
                {
                    var track = station.Tracks[t];
                    @foreach (var stationCall in Current.Trains.SelectMany(t => t.Calls.Where(c => track.Equals(c.Track) && station.Equals(c.Track.Station))))
                    {
                        var trackLine = Current.TrainAtStationLine(AxisDirection, s, t, stationCall);
                        <line stroke="red" stroke-width="@TrainStrokeWidth" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                    }
                }
            }


            @for (var s = 1; s < Current.Stations.Length; s++)
            {
                var fromStationIndex = s - 1;
                var toStationIndex = s;
                var fromStation = Current.Stations[fromStationIndex];
                var toStation = Current.Stations[toStationIndex];

                @for (var t1 = 0; t1 < Current.Stations[fromStationIndex].Tracks.Length; t1++)
                {
                    var fromTrack = Current.Stations[fromStationIndex].Tracks[t1];
                    for (var t2 = 0; t2 < Current.Stations[toStationIndex].Tracks.Length; t2++)
                    {
                        var toTrack = Current.Stations[toStationIndex].Tracks[t2];

                        @foreach (var stretch in Current.Trains.SelectMany(t => t.StretchUses().Where(c => fromStation.Equals(c.From.Track.Station) && c.From.Track.Equals(fromTrack) && toStation.Equals(c.To.Track.Station) && c.To.Track.Equals(toTrack))))
                        {
                            var trackLine = Current.TrainBetweenStationsLine(AxisDirection, s - 1, t1, s, t2, stretch.From.Departure, stretch.To.Arrival);
                            <line stroke="red" stroke-width="@TrainStrokeWidth" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                        }
                    }
                }
            }

            @for (var s = Current.Stations.Length-1; s> 0 ; s--)
            {
                var fromStationIndex = s;
                var toStationIndex = s-1;
                var fromStation = Current.Stations[fromStationIndex];
                var toStation = Current.Stations[toStationIndex];

                @for (var t1 = 0; t1 < fromStation.Tracks.Length; t1++)
                {
                    var fromTrack = fromStation.Tracks[t1];
                    for (var t2 = 0; t2 < toStation.Tracks.Length; t2++)
                    {
                        var toTrack = toStation.Tracks[t2];

                        @foreach (var stretch in Current.Trains.SelectMany(t => t.StretchUses().Where(c => fromStation.Equals(c.From.Track.Station) && c.From.Track.Equals(fromTrack) && toStation.Equals(c.To.Track.Station) && c.To.Track.Equals(toTrack))))
                        {
                            var trackLine = Current.TrainBetweenStationsLine(AxisDirection, s, t1, s-1, t2, stretch.From.Departure, stretch.To.Arrival);
                            <line stroke="red" stroke-width="@TrainStrokeWidth" x1="@trackLine.Start.X" y1="@trackLine.Start.Y" x2="@trackLine.End.X" y2="@trackLine.End.Y"></line>
                        }
                    }
                }
            }


        </svg>
    </div>
}

<br />
<ul>
    @foreach (var e in Events)
    {
        <li>@e.Type (@e.Args.OffsetX @e.Args.OffsetY) (@e.Args.ClientX @e.Args.ClientY) (@e.Args.ScreenX @e.Args.ScreenY)</li>
    }
</ul>

@code
{
    [Parameter] public IEnumerable<Schedule>? TimetableStretches { get; set; }
    [Parameter] public GraphSettings Settings { get; set; } = GraphSettings.Default;

    Schedule? Current;
    bool ShowVertical;

    string TrackStroke(StationTrack t) => t.HasPlatform ? "#404040" : t.IsScheduled ? "#bfbfbf" : "#ff8080";
    string TrainStroke(Train t) => t.Colour;
    string TrainStrokeWidth => "2";


    void ToggleAxis()
    {
        ShowVertical = !ShowVertical;
    }

    TimeAxisDirection AxisDirection => ShowVertical ? TimeAxisDirection.Vertical : TimeAxisDirection.Horisontal;

    List<(MouseEventArgs Args, string Type)> Events = new List<(MouseEventArgs, string)>();

    protected override void OnParametersSet()
    {
        Current = TimetableStretches?.FirstOrDefault();
    }

    void OnClick(MouseEventArgs e)
    {
        Events.Add((e, nameof(OnClick)));
    }

    void OnMouseDown(MouseEventArgs e)
    {

        //Events.Add((e, nameof(OnMouseDown)));
        //StateHasChanged();
        // Find out what object was clicked:
        // A train between two stations: dragging it moves the rest of the train forwards or backwards in time. Check limits: train part not affected by the move, and start and end limits of schedule.
        // An arrival at a station: dragging it moves the time forwards or backwards in time. Check limits: train part not affected by the move, and start and end limits of schedule.
        // A departure at a station: dragging it moves the time forwards or backwards in time. Check limits: train part not affected by the move, and start and end limits of schedule.
        // A wait at a station: dragging between tracks.
    }

    void OnMouseUp(MouseEventArgs e)
    {
        //Events.Add((e, nameof(OnMouseUp)));
        //StateHasChanged();
        // If object is selected: ends the dragging

    }

    void OnMouseMove(MouseEventArgs e)
    {
        //Events.Add(e);
        //StateHasChanged();
        // If object is selected: performs the dragging
    }

    void OnMouseOut(MouseEventArgs e)
    {
        //Events.Add((e, nameof(OnMouseOut)));
        //StateHasChanged();
        // Cancels operations?
    }

    void OnMouseOver(MouseEventArgs e)
    {
        //Events.Add((e, nameof(OnMouseOver)));
        //StateHasChanged();
        // Highlights objects that are selectable? This is similar to actuallt select something.
    }
}